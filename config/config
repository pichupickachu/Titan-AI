import os
import sys
import logging
from dataclasses import dataclass, field
from dotenv import load_dotenv
from logging.handlers import RotatingFileHandler
from datetime import datetime

# --- LOAD .ENV ---
env_path = os.path.join(os.path.dirname(__file__), '.env')
if os.path.exists(env_path):
    load_dotenv(env_path)
    print(f"‚úÖ Config: .env loaded")
else:
    print("‚ùå Config: .env file not found!")


@dataclass
class Config:
    # ---  TRADING MODE ---
    REAL_TRADING: bool = False  # ‚úÖ ENABLED (Trading real money) / OFF (Simulation)
    LEVERAGE: int = 1  #  Leverage 1x (Spot). Do not increase in choppy markets!

    # ---  ACCESS KEYS ---
    TG_TOKEN: str = os.getenv("TG_TOKEN")
    TG_ADMIN_ID: int = int(os.getenv("TG_ADMIN_ID", 0))
    API_KEY: str = os.getenv("MEXC_API_KEY")
    SECRET_KEY: str = os.getenv("MEXC_SECRET")
    GEMINI_KEY: str = os.getenv("GEMINI_KEY")
    CRYPTOPANIC_KEY = os.getenv("CRYPTOPANIC_KEY", "")

    USE_NEWS_FILTER = True
    NEWS_CHECK_INTERVAL = 300
    FUD_PANIC_SCORE = 8

    # ---  INTELLIGENCE SETTINGS (STRICT FILTER) ---
    USE_AI: bool = True
    AI_CONFIDENCE_THRESHOLD: int = 7  # üõ° Require high confidence (7 out of 10)
    MIN_SCORE: int = 60  # üõ° Min Tech Score (was 50, now 60)

    # ---  CHART SETTINGS ---
    BTC_SYMBOL: str = "BTC/USDT"
    TIMEFRAME: str = "15m"  # üõ° 1h filters noise better than 15m, but 15m gives more entries

    # Coins for trading (Liquid tops, trash removed)
    SYMBOLS: list = field(default_factory=lambda: [
        "BTC/USDT", "ETH/USDT", "SOL/USDT", "BNB/USDT",
        "DOGE/USDT", "XRP/USDT", "LINK/USDT", "ADA/USDT"
    ])

    # ---  STRATEGY: CATCH-UP ---
    USE_CATCH_UP: bool = False #  DISABLED (In ranging markets it catches fake breakouts)
    LEADER_SYMBOL: str = "BTC/USDT"
    LAG_LOOKBACK: int = 12
    LEADER_PUMP_THRESHOLD: float = 1.5
    FOLLOWER_LAG_THRESHOLD: float = 0.5

    # ---  MONEY MANAGEMENT ---
    FEE_RATE: float = 0.001  # Exchange fee (0.1%)
    MIN_ORDER_SIZE: float = 6.5  # Min order on MEXC (5$ + buffer)
    BASE_ORDER_SIZE: float = 20.0  # Base entry size ($)
    USE_SMART_SIZE: bool = True  #  Smart calculation (smaller size during high volatility)

    # ---  RISK MANAGEMENT (PROTECTION) ---
    MAX_OPEN_POSITIONS: int = 8  # Max 8 simultaneous trades (don't spread out)
    MAX_ADDS: int = 1  # Max 1 averaging (DCA)
    DCA_THRESHOLD: float = -0.05  #  Average down only if dropped by 5% (not earlier!)
    MAX_DAILY_LOSS: float = 20.0  # If we lost 20$ in a day - stop the machine
    RISK_PER_TRADE_PCT: float = 0.02  # Risk 2% of deposit per trade

    # --- ‚öôÔ∏è SYSTEM ---
    REPORT_HOUR: int = 9
    PAUSED: bool = False

    DEFAULT_TP = 1.04  # Default Take Profit (+4%). Bot will adjust this dynamically.
    DEFAULT_SL: float = 0.97  # Base Stop Loss (start with -3%). Recalculated dynamically.
    CURRENT_SESSION = "INIT"  # Session name storage (Asia/America).


CFG = Config()


# ---  MARKET MOOD FUNCTION ---
def get_market_mood():
    """
    Determines market requirements based on time of day.
    At night (while we sleep), requirements are stricter.
    """
    current_hour = datetime.now().hour

    # Night in Europe (02:00 - 08:00) = Asian Session. Manipulations happen often.
    is_night = 2 <= current_hour < 8

    if is_night:
        return {
            "name": "üåô NIGHT WATCH",  # Night Watch
            "min_score": CFG.MIN_SCORE + 10,  # üõ° Require 70 score (60+10)
            "cooldown_minutes": 60  # If sold, wait 1 hour before new buy
        }
    else:
        return {
            "name": "‚òÄÔ∏è DAY TRADING",  # Day Trading
            "min_score": CFG.MIN_SCORE,  # Standard
            "cooldown_minutes": 15  # Wait 15 minutes
        }


# ---  LOGGING SETUP ---
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        RotatingFileHandler("bot_titan.log", maxBytes=5 * 1024 * 1024, backupCount=1),
        logging.StreamHandler(sys.stdout)
    ]
)

# Silence extra noise
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("httpcore").setLevel(logging.WARNING)
logging.getLogger("aiosqlite").setLevel(logging.WARNING)
